Early attempts at marrying React-Router and Redux built itself upon an idea that React-Router state should be managed by Redux: the current location was part of Redux state and when that part of Redux state changed then the routing would be performed, therefore a user could perform navigation just by `dispatch()`ing an action, and also had an easy access to the current location in Redux state.

While this is an elegant and smart solution, still I don't feel like React-Router state really belongs to Redux application state. It's like two parallel worlds: the navigation world and the application model world. They don't depend on each other in any way and they're conceptually different and not interconnected. So, I think that React-Router should manage its state by itself.

Then, one may ask, why is this library using `dispatch()` for redirection and navigation? And for page preloading?

The answer is: it could easily be some random global variable instead, like `window.__history__` and `redirect()` would just call `window.__history__.replace()`, but, since javascript is single-threaded, on the server side it simply wouldn't work because that global `window.__history__` variable would be shared among all clients which would result in a really weird navigation for all of them. Ok, so the solution is actually simple: just declare some `var history_storage = { history }` and then just pass it around in all functions. This would work, but it would not only introduce a lot of spaghetti code but also would really be a re-implementation of already existing Redux store. And why invent another wheel then. Just use the one you already have if it doesn't interfere (and it doesn't). So that the reason why this library has `dispatch()` for navigation but still doesn't store router state in Redux state.